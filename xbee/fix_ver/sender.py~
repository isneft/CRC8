#!/usr/bin/env python
# -*- coding: utf-8 -*-

import serial
import time
import cv2
import numpy as np
import binascii


byte=256
brt=9600
comvert=2

def capture_camera(mirror=True, size=None):
    """Capture video from camera"""
    # カメラをキャプチャする
    cap = cv2.VideoCapture(0) # 0はカメラのデバイス番号

    for i in range(10):
        # retは画像を取得成功フラグ
        ret, frame = cap.read()

        # 鏡のように映るか否か
        if mirror is True:
            frame = frame[:,::-1]

        # フレームをリサイズ
        # sizeは例えば(800, 600)
        if size is not None and len(size) == 2:
            frame = cv2.resize(frame, size)

        # フレームを表示する
        cv2.imshow('camera capture', frame)

        k = cv2.waitKey(1) # 1msec待つ
        if k == 27: # ESCキーで終了
            break

    # キャプチャを解放する
    cap.release()
    cv2.destroyAllWindows()
    return frame


def setSerial(mybaudrate,timeout=None):
    com = serial.Serial(
        port     = '/dev/ttyUSB0',
        baudrate = mybaudrate,
        bytesize = serial.EIGHTBITS,
        parity   = serial.PARITY_NONE,
        timeout  = timeout,
        xonxoff  = False,
        rtscts   = False,
        writeTimeout = None,
        dsrdtr       = False,
        interCharTimeout = None)
 
    #bufferクリア
    com.flushInput()
    com.flushOutput()
    return com

def receive():
    com=setSerial(brt)
    com.flushInput()
    text = ""
    text = com.readline()
    print text
    com.close()
    return text

def send(text):
    com=setSerial(brt)
    com.write(text)
    print text
    com.flushInput()
    com.close()


def make_data_stream():
    image = capture_camera()
    image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    orgHeight, orgWidth = image.shape[:2]
    size = (orgHeight/comvert, orgWidth/comvert)
    halfImg = cv2.resize(image, size)

    image=halfImg
    cv2.imwrite("../log/gray_scale_origin.png", image)
    image_strate = np.reshape(image,(1,np.shape(image)[0]*np.shape(image)[1]))

    out_size=[size[0],size[1]]
    
    return image_strate, out_size

def data_to_text(picture_data, image_size):
    data16=""
    for i in range(np.shape(picture_data)[1]):
        data16 += hex((picture_data[0][i]))[2:]
    short_text=""
    for i in range(len(data16)/2):
        short_text += binascii.a2b_hex(data16[i*2:i*2+2])

    text = "start:%d:%d@"%(image_size[0],image_size[1])
    text = text + short_text + "&end\r\n"

    print "image size : %d KB"%int(len(text)*8/1024)
    print "data length : %d" %len(short_text)
    
    return text

def send_part(send_data):
    start = time.time()
    for i in range(int(float(len(send_data)/byte))+1):
        
        packetNum = "%d"%i
        if len(packetNum)==1:
            packetNum = "00"+ packetNum
        elif len(packetNum)==2:
            packetNum = "0" + packetNum

        check_sum_org = send_data[i*byte:(i+1)*byte].split("@")[-1]
        check_sum_org = check_sum_org.split("&")[0]
        check_sum=0

        if len(check_sum_org)%2==1:
            check_sum_org = check_sum_org+"0"
            
        for check in range(len(check_sum_org)/2):
            target=check_sum_org[check*2:(check+1)*2]
            num16 = binascii.b2a_hex(target)
            check_sum+=int(num16,16)

        check_sum_str = str(check_sum)
        send_message = packetNum + "," + check_sum_str + "," +send_data[i*byte:(i+1)*byte] + "\r\n"
        print send_message


        for j in range(50):
            com = setSerial(brt)
            com.write(send_message)
            com.flushInput()
            com.close()
            com = setSerial(brt,0.5)
            ACK=com.readline()
        
            if packetNum in ACK:
                print str(i)+"/"+str(int(float(len(text)/byte)))
                print "OK" + packetNum
                com.close()
                break
            else:
                print "error"
                com.close()
    end = time.time()
    print "send finifh : %d min"%(int(float(end-start)/60)+1)
           
def main():
    picture_data, out_size = make_data_stream()
    text_data = data_to_text(picture_data, out_size)
    send_part(text_data)
    
if __name__=="__main__":
    main()
